import org.scalatest.flatspec.AnyFlatSpec
import scala.io.StdIn           //debug
import chisel3._                //basic data types
import chisel3.iotesters._      //peek poke expert
import scala.util.Random        //debug
import chiseltest._             //test
import chisel3.util._
import chisel3.experimental._
import chisel3.stage._
import Color._
/*
    Be careful to make any decision when stall happens. Because the operand may not be ready
*/
class statistics extends Bundle{
    val branch_cnt       =   UInt(64.W)
    val taken_cnt        =   UInt(64.W)
    val icache_hit_cnt   =   UInt(64.W)
    val dcache_hit_cnt   =   UInt(64.W)
    val load_cnt         =   UInt(64.W)
    val bp_success_cnt   =   UInt(64.W)
}

class TOP extends Module{
    //to make tests easier, we expose the inst fetch ports in top, which can be used by verilator and chiseltest
    //now TOP acts like IF, and IF is useless, just passes the signal
    val io = IO(new Bundle{
        //set by cpp
        //debug-use signals, just add to the output port (top module's input can't be assigned by its sub-Module)
        val timer_i   = Input (UInt(64.W))  // generated by cpp

        val csrData   = Output(new CsrData)
        val stall_o   = Output(UInt(5.W))
        val flush_o   = Output(UInt(5.W))
        val regs      = Output(Vec(32, UInt(64.W)))
        val pc_o      = Output(UInt(64.W))  // set by IF, this port just lets cpp know the value of pc, which is in IF, and we pass it to there
        val inst_o    = Output(UInt(32.W))  // set by cpp
        val o1        = Output(UInt(64.W))  // to avoid dce
        val o2        = Output(UInt(64.W))  // to avoid dce

        val statistics_o    =   Output(new statistics)
    })
    //comb logic, pipeline stages
    val IF          =   Module(new IF)
    val ID          =   Module(new ID)
    val EX          =   Module(new EX)
    val MEM         =   Module(new MEM)
    val WB          =   Module(new WB)
    val Regfile     =   Module(new Regfile)
    val Csr         =   Module(new CSR)
    val Main_Memory =   Module(new MAIN_MEMORY)
    val Control     =   Module(new CONTROL)

    //pipeline registers
    val IF_ID   =   Module(new IF_ID)
    val ID_EX   =   Module(new ID_EX)
    val EX_MEM  =   Module(new EX_MEM)
    val MEM_WB  =   Module(new MEM_WB)

    IF.io.predict_i     :=  ID.io.predict_o
    IF.io.icache_insert_i   :=  Main_Memory.io.icache_insert_o

    IF_ID.io.inst_i     :=  IF.io.inst_o
    IF_ID.io.pc_i       :=  IF.io.pc_o
    IF_ID.io.predict_i  :=  IF.io.predict_o

    IF_ID.io.inst_i     :=  IF.io.inst_o
    IF_ID.io.pc_i       :=  IF.io.pc_o

    Main_Memory.io.memOp_i  :=  MEM.io.memOp_i
    Main_Memory.io.icache_miss_i    :=  IF.io.icache_miss_o
    Main_Memory.io.dcache_miss_i    :=  MEM.io.dcache_miss_o
    Main_Memory.io.sync_i           :=  MEM.io.sync_o

    ID.io.inst_i        :=  IF_ID.io.inst_o
    ID.io.pc_i          :=  IF_ID.io.pc_o
    ID.io.csrData_i     :=  Csr.io.csrData_o
    ID.io.rfData_i      :=  Regfile.io.readRes_o
    ID.io.predict_i     :=  IF_ID.io.predict_o
    ID.io.is_stalled_i  :=  IF_ID.io.id_is_stalled_o
    ID.io.mem_miss_i    :=  MEM.io.mem_miss_o

    //bypass
    ID.io.fwd_i.ex    :=  EX.io.ex_fwd_o
    ID.io.fwd_i.mem   :=  MEM.io.mem_fwd_o
    ID.io.fwd_i.wb    :=  WB.io.wb_fwd_o

    ID.io.fwd_i.prev_is_load    :=  EX.io.memOp_o.is_load
    ID.io.fwd_i.prev_rd         :=  EX.io.writeOp_o.rf.rd

    ID_EX.io.debug_i    :=  ID.io.debug_o
    ID_EX.io.decInfo_i  :=  ID.io.decInfo_o

    Regfile.io.readRfOp_i     :=  ID.io.readOp_o
    Regfile.io.writeRfOp_i    :=  WB.io.writeOp_o.rf
    //read
    Csr.io.csrAddr_i    :=  ID.io.readOp_o.csrAddr
    Csr.io.writeOp_i    :=  WB.io.writeOp_o.csr

    EX.io.decInfo_i     :=  ID_EX.io.decInfo_o
    EX.io.ex_is_stalled_i   :=  ID_EX.io.ex_is_stalled_o

    EX_MEM.io.writeOp_i :=  EX.io.writeOp_o
    EX_MEM.io.memOp_i   :=  EX.io.memOp_o
    EX_MEM.io.debug_i   :=  EX.io.debug_o

    MEM.io.writeOp_i    :=  EX_MEM.io.writeOp_o
    MEM.io.memOp_i      :=  EX_MEM.io.memOp_o
    MEM.io.dcache_insert_i   :=  Main_Memory.io.dcache_insert_o
    MEM.io.qword_i      :=  Main_Memory.io.qword_o
    MEM.io.is_stalled_i :=  EX_MEM.io.mem_is_stalled_o

    MEM_WB.io.writeOp_i     :=  MEM.io.writeOp_o
    MEM_WB.io.debug_i       :=  MEM.io.debug_o
    MEM_WB.io.mem_miss_i    :=  MEM.io.mem_miss_o

    WB.io.writeOp_i     :=  MEM_WB.io.writeOp_o

    //TOP module's output, for debug use and also to avoid dce
    io.o1       :=  WB.io.writeOp_o.rf.wdata
    io.o2       :=  WB.io.writeOp_o.csr.wdata

    io.inst_o   :=  IF.io.inst_o
    io.pc_o     :=  IF.io.pc_o
    io.regs     :=  Regfile.io.regs_o
    io.csrData  :=  Csr.io.csrData_o

    dontTouch(io.csrData)
    dontTouch(io.regs)

    IF.io.ctrl_i.flush      :=  Control.io.flush_o(0)
    IF.io.ctrl_i.stall      :=  Control.io.stall_o(0)

    IF_ID.io.ctrl_i.flush   :=  Control.io.flush_o(1)
    IF_ID.io.ctrl_i.stall   :=  Control.io.stall_o(1)

    ID_EX.io.ctrl_i.flush   :=  Control.io.flush_o(2)
    ID_EX.io.ctrl_i.stall   :=  Control.io.stall_o(2)

    EX_MEM.io.ctrl_i.flush  :=  Control.io.flush_o(3)
    EX_MEM.io.ctrl_i.stall  :=  Control.io.stall_o(3)

    MEM_WB.io.ctrl_i.flush  :=  Control.io.flush_o(4)
    MEM_WB.io.ctrl_i.stall  :=  Control.io.stall_o(4)

    // control
    Control.io.id_flush_req_i   :=  ID.io.flush_req_o
    Control.io.if_stall_req_i   :=  IF.io.stall_req_o
    Control.io.mem_stall_req_i  :=  MEM.io.stall_req_o
    Control.io.ex_stall_req_i   :=  EX.io.stall_req_o

    Control.io.id_stall_req_i   :=  ID.io.stall_req_o

    //used to help calculating ipc
    io.stall_o  :=  Control.io.stall_o
    io.flush_o  :=  Control.io.flush_o

    io.statistics_o.branch_cnt      :=  ID.io.nr_branch_o
    io.statistics_o.taken_cnt       :=  ID.io.nr_taken_o
    io.statistics_o.bp_success_cnt  :=  IF.io.success_cnt_o
    io.statistics_o.icache_hit_cnt  :=  IF.io.nr_icache_hit_o
    io.statistics_o.dcache_hit_cnt  :=  MEM.io.nr_dcache_hit_o
    io.statistics_o.load_cnt        :=  MEM.io.nr_load_o

    dontTouch(io.statistics_o)

    EX.io. debug_i  :=  ID_EX.io.debug_o
    MEM.io.debug_i  :=  EX_MEM.io.debug_o
    WB.io.debug_i   :=  MEM_WB.io.debug_o
}

object Gen {
    def main(args:Array[String]) : Unit = {
        println(Yellow("Generate Verilog..."))
        //println(getVerilogString(new seg_scan))
        val my_args = Array("--target-dir", "src/main/scala/verilator/verilog/")
        (new chisel3.stage.ChiselStage).emitVerilog(new TOP, my_args)      //--target-dir , --no-dce
        //(new chisel3.stage.ChiselStage).execute(my_args, Seq(ChiselGeneratorAnnotation(() => new TOP)))

        println(Green("Done"))
    }
}